import type React from "react";
import {
  Clock,
  ShieldCheck,
  XCircle,
  CheckCircle,
  Loader2,
} from "lucide-react";
import type { SREEvent } from "@/lib/sre-events";

export type IssueStatus =
  | "pending"
  | "approved"
  | "applying"
  | "resolved"
  | "rejected";

export interface DiffLine {
  type: "added" | "removed" | "context";
  content: string;
}

export interface ProposedFix {
  action: string;
  description: string;
  file?: string;
  diff?: DiffLine[];
}

const EVENT_FIXES: Record<string, ProposedFix> = {
  "evt-001": {
    action: "Enforce strict rate limiting for abusive IP range",
    description:
      "The agent identified a DDoS pattern from 198.51.100.0/24 generating 12,400 req/s against /api/checkout. The proposed fix adds an aggressive rate limit rule that caps this CIDR block to 10 req/s with automatic 30-minute bans on violation, while preserving normal traffic flow for all other clients.",
    file: "api-gateway/config/rate-limiter.yaml",
    diff: [
      { type: "context", content: "# rate-limiter.yaml" },
      { type: "context", content: "rules:" },
      { type: "context", content: "  - path: /api/checkout" },
      { type: "context", content: "    limit: 500" },
      { type: "context", content: "    window: 1s" },
      { type: "context", content: "    action: reject" },
      { type: "context", content: "" },
      { type: "added", content: "  # DDoS mitigation — auto-generated by agent" },
      { type: "added", content: "  - path: /api/checkout" },
      { type: "added", content: "    match:" },
      { type: "added", content: "      source_cidr: 198.51.100.0/24" },
      { type: "added", content: "    limit: 10" },
      { type: "added", content: "    window: 1s" },
      { type: "added", content: "    action: reject" },
      { type: "added", content: "    ban_duration: 30m" },
      { type: "added", content: "    log: true" },
      { type: "context", content: "  - path: /api/search" },
      { type: "context", content: "    limit: 500" },
      { type: "context", content: "    window: 1s" },
    ],
  },
};

const DEFAULT_FIXES: Record<string, ProposedFix> = {
  incident_detected: {
    action: "Enable circuit breaker & scale up replicas",
    description:
      "The agent will enable the circuit breaker on the affected service to stop cascading failures, then scale the deployment from 3 to 5 replicas to absorb the error backlog.",
  },
  root_cause_found: {
    action: "Reduce timeout & enable retry with backoff",
    description:
      "The agent will update the upstream adapter timeout from 30s to 5s and enable exponential retry with a maximum of 3 attempts to prevent connection pool exhaustion.",
  },
  config_change: {
    action: "Apply recommended config patch",
    description:
      "The agent will apply the configuration diff shown above to production. The change has been validated against the canary environment with zero errors over a 15-minute window.",
  },
  instrumentation_update: {
    action: "Deploy updated probe to all replicas",
    description:
      "The agent will compile the eBPF probe for the target kernel version and deploy it across all replicas. Histogram collection will be verified post-deployment.",
  },
  metric_anomaly: {
    action: "Auto-scale & trigger resource profiling",
    description:
      "The agent will initiate horizontal auto-scaling based on current load, and attach a resource profiler to identify the root cause of the anomaly.",
  },
  service_topology_change: {
    action: "Update service mesh routing rules",
    description:
      "The agent will update the Envoy sidecar configuration to reflect the new topology and ensure traffic is routed correctly to healthy endpoints.",
  },
  alert_resolved: {
    action: "Close incident & update post-mortem",
    description:
      "The agent will mark the incident as resolved in the incident management system, close the PagerDuty alert, and generate a post-mortem draft.",
  },
  deployment_detected: {
    action: "Promote canary to stable",
    description:
      "The agent will shift 100% of traffic to the new version after confirming error rate and latency are within SLO thresholds during the canary window.",
  },
  runbook_executed: {
    action: "Execute automated remediation runbook",
    description:
      "The agent will run the associated runbook steps sequentially with rollback checkpoints. Each step will be verified before proceeding to the next.",
  },
};

export function getProposedFix(event: SREEvent): ProposedFix {
  return (
    EVENT_FIXES[event.id] ??
    DEFAULT_FIXES[event.eventType] ??
    DEFAULT_FIXES.incident_detected
  );
}

export function getInitialStatus(event: SREEvent): IssueStatus {
  if (event.id === "evt-001") return "pending";
  return "resolved";
}

export const STATUS_CONFIG: Record<
  IssueStatus,
  { label: string; color: string; bg: string; icon: React.ComponentType<{ size?: number; className?: string }> }
> = {
  pending: {
    label: "Awaiting Approval",
    color: "text-amber-600 dark:text-amber-400",
    bg: "bg-amber-50 dark:bg-amber-950/30",
    icon: Clock,
  },
  approved: {
    label: "Approved",
    color: "text-blue-600 dark:text-blue-400",
    bg: "bg-blue-50 dark:bg-blue-950/30",
    icon: ShieldCheck,
  },
  applying: {
    label: "Applying Fix…",
    color: "text-blue-600 dark:text-blue-400",
    bg: "bg-blue-50 dark:bg-blue-950/30",
    icon: Loader2,
  },
  resolved: {
    label: "Applied",
    color: "text-emerald-600 dark:text-emerald-400",
    bg: "bg-emerald-50 dark:bg-emerald-950/30",
    icon: CheckCircle,
  },
  rejected: {
    label: "Rejected",
    color: "text-neutral-500 dark:text-neutral-400",
    bg: "bg-neutral-50 dark:bg-neutral-800/30",
    icon: XCircle,
  },
};
